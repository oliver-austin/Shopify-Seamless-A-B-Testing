import * as tslib_1 from "tslib";
import * as React from 'react';
import { createUniqueIDFactory } from '@shopify/javascript-utilities/other';
import { addEventListener, removeEventListener, } from '@shopify/javascript-utilities/events';
import { autobind } from '@shopify/javascript-utilities/decorators';
import OptionList from '../../../OptionList';
import ActionList from '../../../ActionList';
import Popover from '../../../Popover';
import { Key } from '../../../../types';
import { contextTypes } from '../types';
import KeypressListener from '../../../KeypressListener';
import { TextField } from './components';
import styles from './ComboBox.scss';
const getUniqueId = createUniqueIDFactory('ComboBox');
export default class ComboBox extends React.PureComponent {
    constructor() {
        super(...arguments);
        this.state = {
            comboBoxId: this.getComboBoxId(),
            selectedOption: undefined,
            selectedIndex: -1,
            selectedOptions: this.props.selected,
            navigableOptions: [],
            popoverActive: false,
            popoverWasActive: false,
        };
        this.subscriptions = [];
        this.popoverScrollContainer = React.createRef();
    }
    static getDerivedStateFromProps({ options: nextOptions, selected: nextSelected, actionsBefore: nextActionsBefore, actionsAfter: nextActionsAfter, }, { navigableOptions, selectedOptions, comboBoxId }) {
        const optionsChanged = filterForOptions(navigableOptions) &&
            nextOptions &&
            !optionsAreEqual(navigableOptions, nextOptions);
        let newNavigableOptions = [];
        if (nextActionsBefore) {
            newNavigableOptions = newNavigableOptions.concat(nextActionsBefore);
        }
        if (optionsChanged || nextActionsBefore) {
            newNavigableOptions = newNavigableOptions.concat(nextOptions);
        }
        if (nextActionsAfter) {
            newNavigableOptions = newNavigableOptions.concat(nextActionsAfter);
        }
        newNavigableOptions = assignOptionIds(newNavigableOptions, comboBoxId);
        if (optionsChanged && selectedOptions !== nextSelected) {
            return {
                navigableOptions: newNavigableOptions,
                selectedOptions: nextSelected,
            };
        }
        else if (optionsChanged) {
            return {
                navigableOptions: newNavigableOptions,
            };
        }
        else if (selectedOptions !== nextSelected) {
            return { selectedOptions: nextSelected };
        }
        return null;
    }
    getChildContext() {
        return {
            comboBoxId: this.state.comboBoxId,
            selectedOptionId: this.getSelectedOptionId(),
            subscribe: this.subscribe,
            unsubscribe: this.unsubscribe,
        };
    }
    componentDidMount() {
        const { options, actionsBefore, actionsAfter } = this.props;
        const comboBoxId = this.getComboBoxId();
        let navigableOptions = [];
        if (actionsBefore) {
            navigableOptions = navigableOptions.concat(actionsBefore);
        }
        if (options) {
            navigableOptions = navigableOptions.concat(options);
        }
        if (actionsAfter) {
            navigableOptions = navigableOptions.concat(actionsAfter);
        }
        navigableOptions = assignOptionIds(navigableOptions, comboBoxId);
        this.setState({
            navigableOptions,
        });
    }
    componentDidUpdate(_, prevState) {
        const { contentBefore, contentAfter, emptyState } = this.props;
        const { navigableOptions, popoverActive, popoverWasActive } = this.state;
        this.subscriptions.forEach((subscriberCallback) => subscriberCallback());
        const optionsChanged = navigableOptions &&
            prevState.navigableOptions &&
            !optionsAreEqual(navigableOptions, prevState.navigableOptions);
        const popoverChanged = popoverActive === prevState.popoverActive;
        if (optionsChanged) {
            this.updateIndexOfSelectedOption(navigableOptions);
        }
        if (navigableOptions &&
            navigableOptions.length === 0 &&
            !contentBefore &&
            !contentAfter &&
            !emptyState) {
            // eslint-disable-next-line react/no-did-update-set-state
            this.setState({ popoverActive: false });
        }
        else if (popoverWasActive &&
            navigableOptions &&
            navigableOptions.length !== 0) {
            // eslint-disable-next-line react/no-did-update-set-state
            this.setState({ popoverActive: true });
        }
        if (popoverChanged) {
            popoverActive ? this.addScrollListener() : this.removeScrollListener();
        }
    }
    getComboBoxId() {
        if (this.state && this.state.comboBoxId) {
            return this.state.comboBoxId;
        }
        return this.props.id || getUniqueId();
    }
    render() {
        const { options, textField, listTitle, allowMultiple, preferredPosition, actionsBefore, actionsAfter, contentBefore, contentAfter, onEndReached, emptyState, } = this.props;
        const actionsBeforeMarkup = actionsBefore &&
            actionsBefore.length > 0 && (<ActionList actionRole="option" items={actionsBefore}/>);
        const actionsAfterMarkup = actionsAfter &&
            actionsAfter.length > 0 && (<ActionList actionRole="option" items={actionsAfter}/>);
        const optionsMarkup = options.length > 0 && (<OptionList role="presentation" optionRole="option" options={filterForOptions(this.state.navigableOptions)} onChange={this.selectOptions} selected={this.state.selectedOptions} title={listTitle} allowMultiple={allowMultiple}/>);
        const scrollListenerMarkup = onEndReached && (<div ref={this.popoverScrollContainer}/>);
        const emptyStateMarkup = !actionsAfter &&
            !actionsBefore &&
            !contentAfter &&
            !contentBefore &&
            options.length === 0 &&
            emptyState && <div className={styles.EmptyState}>{emptyState}</div>;
        return (<div onClick={this.handleClick} role="combobox" aria-expanded={this.state.popoverActive} aria-owns={this.state.comboBoxId} aria-controls={this.state.comboBoxId} aria-haspopup onFocus={this.handleFocus} onBlur={this.handleBlur} tabIndex={0}>
        <KeypressListener keyCode={Key.DownArrow} handler={this.handleDownArrow}/>
        <KeypressListener keyCode={Key.UpArrow} handler={this.handleUpArrow}/>
        <KeypressListener keyCode={Key.Enter} handler={this.handleEnter}/>
        <KeypressListener keyCode={Key.Escape} handler={this.handlePopoverClose}/>
        <Popover activator={textField} active={this.state.popoverActive} onClose={this.handlePopoverClose} preferredPosition={preferredPosition} fullWidth preventAutofocus>
          <div id={this.state.comboBoxId} role="listbox" aria-multiselectable={allowMultiple}>
            {scrollListenerMarkup}
            {contentBefore}
            {actionsBeforeMarkup}
            {optionsMarkup}
            {actionsAfterMarkup}
            {contentAfter}
            {emptyStateMarkup}
          </div>
        </Popover>
      </div>);
    }
    subscribe(callback) {
        this.subscriptions.push(callback);
    }
    unsubscribe(callback) {
        this.subscriptions = this.subscriptions.filter((subscription) => subscription !== callback);
    }
    handleDownArrow() {
        const { selectedIndex, navigableOptions } = this.state;
        const { onEndReached } = this.props;
        if (navigableOptions &&
            selectedIndex === navigableOptions.length - 1 &&
            onEndReached) {
            onEndReached();
        }
        this.selectNextOption();
        this.handlePopoverOpen;
    }
    handleUpArrow() {
        this.selectPreviousOption();
        this.handlePopoverOpen;
    }
    handleEnter() {
        const { selectedOption } = this.state;
        if (this.state.popoverActive && selectedOption) {
            if (isOption(selectedOption)) {
                this.handleSelection(selectedOption.value);
            }
            else {
                selectedOption.onAction && selectedOption.onAction();
            }
        }
        this.handlePopoverOpen;
    }
    handleFocus() {
        this.setState({ popoverActive: true, popoverWasActive: true });
    }
    handleBlur() {
        this.setState({ popoverActive: false, popoverWasActive: false }, () => {
            this.resetVisuallySelectedOptions();
        });
    }
    handleClick() {
        !this.state.popoverActive && this.setState({ popoverActive: true });
    }
    handleScroll() {
        const { onEndReached } = this.props;
        if (!onEndReached) {
            return;
        }
        if (this.popoverScrollContainer.current) {
            const scrollContainer = this.popoverScrollContainer.current.parentElement;
            if (scrollContainer &&
                scrollContainer.scrollTop >
                    scrollContainer.scrollHeight - scrollContainer.offsetHeight - 1) {
                onEndReached();
            }
        }
    }
    handleSelection(newSelected) {
        const { selected, allowMultiple } = this.props;
        let newlySelectedOptions = selected;
        if (selected.includes(newSelected)) {
            newlySelectedOptions.splice(newlySelectedOptions.indexOf(newSelected), 1);
        }
        else if (allowMultiple) {
            newlySelectedOptions.push(newSelected);
        }
        else {
            newlySelectedOptions = [newSelected];
        }
        this.selectOptions(newlySelectedOptions);
    }
    selectOptions(selected) {
        const { onSelect, allowMultiple } = this.props;
        selected && onSelect(selected);
        if (!allowMultiple) {
            this.resetVisuallySelectedOptions();
            this.setState({ popoverActive: false, popoverWasActive: false });
        }
    }
    updateIndexOfSelectedOption(newOptions) {
        const { selectedIndex, selectedOption } = this.state;
        if (selectedOption && newOptions.includes(selectedOption)) {
            this.selectOptionAtIndex(newOptions.indexOf(selectedOption));
        }
        else if (selectedIndex > newOptions.length - 1) {
            this.resetVisuallySelectedOptions();
        }
        else {
            this.selectOptionAtIndex(selectedIndex);
        }
    }
    resetVisuallySelectedOptions() {
        const { navigableOptions } = this.state;
        this.setState({
            selectedOption: undefined,
            selectedIndex: -1,
        });
        navigableOptions &&
            navigableOptions.forEach((option) => {
                option.active = false;
            });
    }
    handlePopoverClose() {
        this.setState({ popoverActive: false, popoverWasActive: false });
    }
    handlePopoverOpen() {
        const { popoverActive, navigableOptions } = this.state;
        !popoverActive &&
            navigableOptions &&
            navigableOptions.length > 0 &&
            this.setState({ popoverActive: true, popoverWasActive: true });
    }
    selectNextOption() {
        const { selectedIndex, navigableOptions } = this.state;
        if (!navigableOptions || navigableOptions.length === 0) {
            return;
        }
        let newIndex = selectedIndex;
        if (selectedIndex + 1 >= navigableOptions.length) {
            newIndex = 0;
        }
        else {
            newIndex++;
        }
        this.selectOptionAtIndex(newIndex);
    }
    selectPreviousOption() {
        const { selectedIndex, navigableOptions } = this.state;
        if (!navigableOptions || navigableOptions.length === 0) {
            return;
        }
        let newIndex = selectedIndex;
        if (selectedIndex <= 0) {
            newIndex = navigableOptions.length - 1;
        }
        else {
            newIndex--;
        }
        this.selectOptionAtIndex(newIndex);
    }
    selectOptionAtIndex(newOptionIndex) {
        const { navigableOptions, selectedOption: oldSelectedOption } = this.state;
        if (!navigableOptions || navigableOptions.length === 0) {
            return;
        }
        const newSelectedOption = navigableOptions[newOptionIndex];
        this.setState({
            selectedOption: newSelectedOption,
            selectedIndex: newOptionIndex,
        }, () => {
            this.visuallyUpdateSelectedOption(newSelectedOption, oldSelectedOption);
        });
    }
    visuallyUpdateSelectedOption(newOption, oldOption) {
        if (oldOption) {
            oldOption.active = false;
        }
        if (newOption) {
            newOption.active = true;
        }
    }
    getSelectedOptionId() {
        const { selectedOption, selectedIndex, comboBoxId } = this.state;
        return selectedOption ? `${comboBoxId}-${selectedIndex}` : undefined;
    }
    addScrollListener() {
        this.popoverScrollContainer.current &&
            this.popoverScrollContainer.current.parentElement &&
            addEventListener(this.popoverScrollContainer.current.parentElement, 'scroll', this.handleScroll, { passive: true });
    }
    removeScrollListener() {
        this.popoverScrollContainer.current &&
            this.popoverScrollContainer.current.parentElement &&
            removeEventListener(this.popoverScrollContainer.current.parentElement, 'scroll', this.handleScroll);
    }
}
ComboBox.TextField = TextField;
ComboBox.OptionList = OptionList;
ComboBox.childContextTypes = contextTypes;
tslib_1.__decorate([
    autobind
], ComboBox.prototype, "subscribe", null);
tslib_1.__decorate([
    autobind
], ComboBox.prototype, "unsubscribe", null);
tslib_1.__decorate([
    autobind
], ComboBox.prototype, "handleDownArrow", null);
tslib_1.__decorate([
    autobind
], ComboBox.prototype, "handleUpArrow", null);
tslib_1.__decorate([
    autobind
], ComboBox.prototype, "handleEnter", null);
tslib_1.__decorate([
    autobind
], ComboBox.prototype, "handleFocus", null);
tslib_1.__decorate([
    autobind
], ComboBox.prototype, "handleBlur", null);
tslib_1.__decorate([
    autobind
], ComboBox.prototype, "handleClick", null);
tslib_1.__decorate([
    autobind
], ComboBox.prototype, "handleScroll", null);
tslib_1.__decorate([
    autobind
], ComboBox.prototype, "handleSelection", null);
tslib_1.__decorate([
    autobind
], ComboBox.prototype, "selectOptions", null);
tslib_1.__decorate([
    autobind
], ComboBox.prototype, "updateIndexOfSelectedOption", null);
tslib_1.__decorate([
    autobind
], ComboBox.prototype, "resetVisuallySelectedOptions", null);
tslib_1.__decorate([
    autobind
], ComboBox.prototype, "handlePopoverClose", null);
tslib_1.__decorate([
    autobind
], ComboBox.prototype, "handlePopoverOpen", null);
tslib_1.__decorate([
    autobind
], ComboBox.prototype, "selectNextOption", null);
tslib_1.__decorate([
    autobind
], ComboBox.prototype, "selectPreviousOption", null);
tslib_1.__decorate([
    autobind
], ComboBox.prototype, "selectOptionAtIndex", null);
tslib_1.__decorate([
    autobind
], ComboBox.prototype, "visuallyUpdateSelectedOption", null);
tslib_1.__decorate([
    autobind
], ComboBox.prototype, "getSelectedOptionId", null);
tslib_1.__decorate([
    autobind
], ComboBox.prototype, "addScrollListener", null);
tslib_1.__decorate([
    autobind
], ComboBox.prototype, "removeScrollListener", null);
function assignOptionIds(options, comboBoxId) {
    options.map((option, optionIndex) => {
        option.id = `${comboBoxId}-${optionIndex}`;
    });
    return options;
}
function optionsAreEqual(firstOptions, secondOptions) {
    if (firstOptions.length !== secondOptions.length) {
        return false;
    }
    return firstOptions.every((firstItem, index) => {
        const secondItem = secondOptions[index];
        if (isOption(firstItem)) {
            if (isOption(secondItem)) {
                return firstItem.value === secondItem.value;
            }
            return false;
        }
        else {
            if (!isOption(secondItem)) {
                return firstItem.content === secondItem.content;
            }
            return false;
        }
    });
}
function isOption(navigableOption) {
    return navigableOption.value !== undefined;
}
function filterForOptions(mixedArray) {
    return mixedArray.filter((item) => isOption(item));
}

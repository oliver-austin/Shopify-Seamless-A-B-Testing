import * as tslib_1 from "tslib";
import * as React from 'react';
import { autobind } from '@shopify/javascript-utilities/decorators';
import EventListener from '../../../EventListener';
import styles from '../../TextField.scss';
export default class Resizer extends React.PureComponent {
    constructor() {
        super(...arguments);
        this.contentNode = null;
        this.minimumLinesNode = null;
    }
    componentDidMount() {
        this.handleHeightCheck();
        if (process.env.NODE_ENV === 'development') {
            // We need to defer the calculation in development so the
            // styles have time to be injected.
            setTimeout(this.handleHeightCheck, 0);
        }
    }
    componentDidUpdate() {
        this.handleHeightCheck();
    }
    render() {
        const { contents, minimumLines } = this.props;
        const minimumLinesMarkup = minimumLines ? (<div testID="MinimumLines" ref={this.setMinimumLinesNode} className={styles.DummyInput} dangerouslySetInnerHTML={{
            __html: getContentsForMinimumLines(minimumLines),
        }}/>) : null;
        return (<div testID="ResizerWrapper" aria-hidden className={styles.Resizer}>
        <EventListener event="resize" handler={this.handleHeightCheck}/>
        <div testID="ContentsNode" ref={this.setContentNode} className={styles.DummyInput} dangerouslySetInnerHTML={{ __html: getFinalContents(contents) }}/>
        {minimumLinesMarkup}
      </div>);
    }
    handleHeightCheck() {
        if (this.contentNode == null || this.minimumLinesNode == null) {
            return;
        }
        const contentHeight = this.contentNode.offsetHeight;
        const minimumHeight = this.setMinimumLinesNode
            ? this.minimumLinesNode.offsetHeight
            : 0;
        const newHeight = Math.max(contentHeight, minimumHeight);
        const { currentHeight, onHeightChange } = this.props;
        if (newHeight !== currentHeight) {
            onHeightChange(newHeight);
        }
    }
    setContentNode(node) {
        this.contentNode = node;
    }
    setMinimumLinesNode(node) {
        this.minimumLinesNode = node;
    }
}
tslib_1.__decorate([
    autobind
], Resizer.prototype, "handleHeightCheck", null);
tslib_1.__decorate([
    autobind
], Resizer.prototype, "setContentNode", null);
tslib_1.__decorate([
    autobind
], Resizer.prototype, "setMinimumLinesNode", null);
const ENTITIES_TO_REPLACE = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '\n': '<br>',
};
const REPLACE_REGEX = /[\n&<>]/g;
function replaceEntity(entity) {
    return ENTITIES_TO_REPLACE[entity] || entity;
}
function getContentsForMinimumLines(minimumLines) {
    let content = '';
    for (let line = 0; line < minimumLines; line++) {
        content += '<br>';
    }
    return content;
}
function getFinalContents(contents) {
    return contents
        ? `${contents.replace(REPLACE_REGEX, replaceEntity)}<br>`
        : '<br>';
}
